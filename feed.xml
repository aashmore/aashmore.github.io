<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://aashmore.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://aashmore.github.io/" rel="alternate" type="text/html" /><updated>2024-10-16T15:00:31+00:00</updated><id>https://aashmore.github.io/feed.xml</id><title type="html">Skidmore Computational Physics &amp;amp; ML Lab</title><subtitle>A computational physics and machine learning research group at Skidmore College.</subtitle><entry><title type="html">Mathematica tips for numerical linear algebra (4)</title><link href="https://aashmore.github.io/2022/10/14/mathematica-4.html" rel="alternate" type="text/html" title="Mathematica tips for numerical linear algebra (4)" /><published>2022-10-14T00:00:00+00:00</published><updated>2022-10-14T00:00:00+00:00</updated><id>https://aashmore.github.io/2022/10/14/mathematica-4</id><content type="html" xml:base="https://aashmore.github.io/2022/10/14/mathematica-4.html"><![CDATA[<h2 id="transpose-and-flatten">Transpose and Flatten</h2>

<!-- excerpt start -->
<p>So now we know how to multiply matrices using Mathematica’s <code class="language-plaintext highlighter-rouge">Dot</code> function. This also works for higher-rank tensors (more indices) such as $m_{abc} n_{cde} = (mn)_{abde}$, which we can implement as
<!-- excerpt end --></p>

<div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">RandomComplex</span><span class="p">[{}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="m">10</span><span class="o">,</span><span class="w"> </span><span class="m">20</span><span class="o">,</span><span class="w"> </span><span class="m">30</span><span class="p">}]</span><span class="o">;</span><span class="w">
</span><span class="nv">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">RandomComplex</span><span class="p">[{}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="m">30</span><span class="o">,</span><span class="w"> </span><span class="m">40</span><span class="o">,</span><span class="w"> </span><span class="m">50</span><span class="p">}]</span><span class="o">;</span><span class="w">

</span><span class="nv">m</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nb">Dimensions</span><span class="w">
</span><span class="c">(* {10,20,30} *)</span><span class="w">
</span><span class="nv">n</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nb">Dimensions</span><span class="w">
</span><span class="c">(* {30,40,50} *)</span><span class="w">

</span><span class="nv">m</span><span class="o">.</span><span class="nv">n</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nb">Dimensions</span><span class="w">
</span><span class="c">(* {10,20,40,50} *)</span><span class="w">
</span></code></pre></div></div>

<p>Here we used <code class="language-plaintext highlighter-rouge">Dimensions</code> to see that check that $m_{abc}$ is indeed a rank-three tensor of size <code class="language-plaintext highlighter-rouge">{10,20,30}</code>, and that <code class="language-plaintext highlighter-rouge">Dot</code> contracts the adjacent indices in <code class="language-plaintext highlighter-rouge">m.n</code>, leaving the remaining indices in the same order.</p>

<p>What if the indices we want to contract aren’t adjacent? The trick is to shuffle the indices of our tensors using either <code class="language-plaintext highlighter-rouge">Transpose</code> or <code class="language-plaintext highlighter-rouge">Flatten</code>.</p>

<h2 id="transpose">Transpose</h2>

<p>Let’s start with <code class="language-plaintext highlighter-rouge">Transpose</code>. Given a tensor $m$, the two simplest uses of this function are <code class="language-plaintext highlighter-rouge">Transpose[m]</code> and <code class="language-plaintext highlighter-rouge">Transpose[m, k&lt;-&gt;l]</code>. The first of these transposes the first two indices of $m$:</p>

<div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">RandomComplex</span><span class="p">[{}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="m">10</span><span class="o">,</span><span class="w"> </span><span class="m">20</span><span class="o">,</span><span class="w"> </span><span class="m">30</span><span class="p">}]</span><span class="o">;</span><span class="w">

</span><span class="nv">m</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nb">Dimensions</span><span class="w">
</span><span class="c">(* {10,20,30} *)</span><span class="w">
</span><span class="nb">Transpose</span><span class="p">[</span><span class="nv">m</span><span class="p">]</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nb">Dimensions</span><span class="w">
</span><span class="c">(* {20,10,30} *)</span><span class="w">
</span></code></pre></div></div>

<p>The second form of the function allows us to specify which indices are transposed. For example, taking <code class="language-plaintext highlighter-rouge">k=1</code> and <code class="language-plaintext highlighter-rouge">l=3</code> will transpose the 1st and 3rd indices of $m$:</p>

<div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">RandomComplex</span><span class="p">[{}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="m">10</span><span class="o">,</span><span class="w"> </span><span class="m">20</span><span class="o">,</span><span class="w"> </span><span class="m">30</span><span class="p">}]</span><span class="o">;</span><span class="w">

</span><span class="nv">m</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nb">Dimensions</span><span class="w">
</span><span class="c">(* {10,20,30} *)</span><span class="w">
</span><span class="nb">Transpose</span><span class="p">[</span><span class="nv">m</span><span class="o">,</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="o">&lt;-&gt;</span><span class="w"> </span><span class="m">3</span><span class="p">]</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nb">Dimensions</span><span class="w">
</span><span class="c">(* {30,20,10} *)</span><span class="w">
</span></code></pre></div></div>

<p>Using this second form, we can contract tensors such as $m_{abc} p_{dec}$:</p>

<div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">RandomComplex</span><span class="p">[{}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="m">10</span><span class="o">,</span><span class="w"> </span><span class="m">20</span><span class="o">,</span><span class="w"> </span><span class="m">30</span><span class="p">}]</span><span class="o">;</span><span class="w">
</span><span class="nv">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">RandomComplex</span><span class="p">[{}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="m">40</span><span class="o">,</span><span class="w"> </span><span class="m">50</span><span class="o">,</span><span class="w"> </span><span class="m">30</span><span class="p">}]</span><span class="o">;</span><span class="w">

</span><span class="nv">m</span><span class="o">.</span><span class="nb">Transpose</span><span class="p">[</span><span class="nv">p</span><span class="o">,</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="o">&lt;-&gt;</span><span class="w"> </span><span class="m">3</span><span class="p">]</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nb">Dimensions</span><span class="w">
</span><span class="c">(* {10,20,50,40} *)</span><span class="w">
</span></code></pre></div></div>

<p>What if we want the indices of the resulting tensor to be ordered as <code class="language-plaintext highlighter-rouge">{10,20,40,50}</code> instead of <code class="language-plaintext highlighter-rouge">{10,20,50,40}</code>? Obviously, we could do the calculation in two steps, first constructing the product as above, and then taking a further transpose on the 3rd and 4th indices. Fortunately, <code class="language-plaintext highlighter-rouge">Transpose</code> can do this in one step. The result of <code class="language-plaintext highlighter-rouge">Transpose[m, {k1, k2, k3}]</code> is a tensor such that the 1st index of $m$ becomes the <code class="language-plaintext highlighter-rouge">k1</code>-th index, the 2nd index of $m$ becomes the <code class="language-plaintext highlighter-rouge">k2</code>-th index, and so on. For example, swapping the first two indices of $m$ is implemented as</p>

<div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">RandomComplex</span><span class="p">[{}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="m">10</span><span class="o">,</span><span class="w"> </span><span class="m">20</span><span class="o">,</span><span class="w"> </span><span class="m">30</span><span class="p">}]</span><span class="o">;</span><span class="w">

</span><span class="nb">Transpose</span><span class="p">[</span><span class="nv">m</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="m">2</span><span class="o">,</span><span class="w"> </span><span class="m">1</span><span class="o">,</span><span class="w"> </span><span class="m">3</span><span class="p">}]</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nb">Dimensions</span><span class="w">
</span><span class="c">(* {20,10,30} *)</span><span class="w">
</span></code></pre></div></div>

<p>which we interpret as sending the 1st index to position 2, the 2nd index to position 1, and leaving the 3rd index unchanged.</p>

<p>We can then perform the contraction of $m$ and $p$ as above but with the 3rd and 4th indices swapped as</p>

<div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">RandomComplex</span><span class="p">[{}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="m">10</span><span class="o">,</span><span class="w"> </span><span class="m">20</span><span class="o">,</span><span class="w"> </span><span class="m">30</span><span class="p">}]</span><span class="o">;</span><span class="w">
</span><span class="nv">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">RandomComplex</span><span class="p">[{}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="m">40</span><span class="o">,</span><span class="w"> </span><span class="m">50</span><span class="o">,</span><span class="w"> </span><span class="m">30</span><span class="p">}]</span><span class="o">;</span><span class="w">

</span><span class="nv">m</span><span class="o">.</span><span class="nb">Transpose</span><span class="p">[</span><span class="nv">p</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="m">3</span><span class="o">,</span><span class="w"> </span><span class="m">2</span><span class="o">,</span><span class="w"> </span><span class="m">1</span><span class="p">}]</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nb">Dimensions</span><span class="w">
</span><span class="c">(* {10,20,50,40} *)</span><span class="w">
</span></code></pre></div></div>

<p>The key to remember how this form of Transpose works is that <em>you specify where the indices end up</em>.</p>

<h2 id="flatten">Flatten</h2>

<p>We can also shuffle indices with the function <code class="language-plaintext highlighter-rouge">Flatten</code>. This function also has other uses – such as letting us contract more than one index at a time – but we’ll focus on using it to transpose for the moment.</p>

<p>The key with <code class="language-plaintext highlighter-rouge">Flatten</code> is that <em>you specify where the indices came from</em>. For example, compare</p>

<div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">RandomComplex</span><span class="p">[{}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="m">10</span><span class="o">,</span><span class="w"> </span><span class="m">20</span><span class="o">,</span><span class="w"> </span><span class="m">30</span><span class="o">,</span><span class="w"> </span><span class="m">40</span><span class="p">}]</span><span class="o">;</span><span class="w">

</span><span class="nb">Transpose</span><span class="p">[</span><span class="nv">m</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="m">1</span><span class="o">,</span><span class="w"> </span><span class="m">4</span><span class="o">,</span><span class="w"> </span><span class="m">2</span><span class="o">,</span><span class="w"> </span><span class="m">3</span><span class="p">}]</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nb">Dimensions</span><span class="w">
</span><span class="c">(* {10,30,40,20} *)</span><span class="w">

</span><span class="nb">Flatten</span><span class="p">[</span><span class="nv">m</span><span class="o">,</span><span class="w"> </span><span class="p">{{</span><span class="m">1</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="m">4</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="m">2</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="m">3</span><span class="p">}}]</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nb">Dimensions</span><span class="w">
</span><span class="c">(* {10,40,20,30} *)</span><span class="w">
</span></code></pre></div></div>

<p>Using <code class="language-plaintext highlighter-rouge">Transpose</code> with the argument <code class="language-plaintext highlighter-rouge">{1, 4, 2, 3}</code>, we leave the 1st index unchanged, send the 2nd index to 4th position, send the 3rd index to 2nd position, and send the 4th index to 3rd position. Using <code class="language-plaintext highlighter-rouge">Flatten</code> with the argument <code class="language-plaintext highlighter-rouge">{{1}, {4}, {2}, {3}}</code>, we leave the 1st index unchanged, set the 2nd index of the result to be the 4th index of the original tensor, set the 3rd index of the result to be the 2nd index of the original tensor, and finally set the 4th index of the result to be the 3rd index of the original tensor. These operations are not the same! And the difference is whether you are thinking about <em>where to send the indices to</em> or <em>where the indices came from</em>.</p>

<p>If we want the same result from both, we would use</p>

<div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">RandomComplex</span><span class="p">[{}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="m">10</span><span class="o">,</span><span class="w"> </span><span class="m">20</span><span class="o">,</span><span class="w"> </span><span class="m">30</span><span class="o">,</span><span class="w"> </span><span class="m">40</span><span class="p">}]</span><span class="o">;</span><span class="w">

</span><span class="nb">Transpose</span><span class="p">[</span><span class="nv">m</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="m">1</span><span class="o">,</span><span class="w"> </span><span class="m">4</span><span class="o">,</span><span class="w"> </span><span class="m">2</span><span class="o">,</span><span class="w"> </span><span class="m">3</span><span class="p">}]</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nb">Dimensions</span><span class="w">
</span><span class="c">(* {10,30,40,20} *)</span><span class="w">

</span><span class="nb">Flatten</span><span class="p">[</span><span class="nv">m</span><span class="o">,</span><span class="w"> </span><span class="p">{{</span><span class="m">1</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="m">3</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="m">4</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="m">2</span><span class="p">}}]</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nb">Dimensions</span><span class="w">
</span><span class="c">(* {10,40,20,30} *)</span><span class="w">

</span><span class="nb">Transpose</span><span class="p">[</span><span class="nv">m</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="m">1</span><span class="o">,</span><span class="w"> </span><span class="m">4</span><span class="o">,</span><span class="w"> </span><span class="m">2</span><span class="o">,</span><span class="w"> </span><span class="m">3</span><span class="p">}]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">Flatten</span><span class="p">[</span><span class="nv">m</span><span class="o">,</span><span class="w"> </span><span class="p">{{</span><span class="m">1</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="m">3</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="m">4</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="m">2</span><span class="p">}}]</span><span class="w">
</span><span class="c">(* True *)</span><span class="w">
</span></code></pre></div></div>

<p>Note that if you just need to transpose a tensor, <code class="language-plaintext highlighter-rouge">Tranpose</code> is often faster than <code class="language-plaintext highlighter-rouge">Flatten</code>. For example, increasing the dimensions of $m$ somewhat:</p>

<div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">RandomComplex</span><span class="p">[{}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="m">10</span><span class="o">,</span><span class="w"> </span><span class="m">200</span><span class="o">,</span><span class="w"> </span><span class="m">300</span><span class="o">,</span><span class="w"> </span><span class="m">400</span><span class="p">}]</span><span class="o">;</span><span class="w">

</span><span class="nb">Transpose</span><span class="p">[</span><span class="nv">m</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="m">1</span><span class="o">,</span><span class="w"> </span><span class="m">4</span><span class="o">,</span><span class="w"> </span><span class="m">2</span><span class="o">,</span><span class="w"> </span><span class="m">3</span><span class="p">}]</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nb">Dimensions</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nb">RepeatedTiming</span><span class="w">
</span><span class="c">(* {0.60360695, {10,300,400,200}} *)</span><span class="w">

</span><span class="nb">Flatten</span><span class="p">[</span><span class="nv">m</span><span class="o">,</span><span class="w"> </span><span class="p">{{</span><span class="m">1</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="m">3</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="m">4</span><span class="p">}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="m">2</span><span class="p">}}]</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nb">Dimensions</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nb">RepeatedTiming</span><span class="w">
</span><span class="c">(* {4.8638016, {10,300,400,200}} *)</span><span class="w">
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Flatten</code> is 8 times slower than <code class="language-plaintext highlighter-rouge">Tranpose</code> in this case! If you have to repeat this operation many thousands of times, this could become a huge bottleneck!</p>]]></content><author><name>anthony-ashmore</name></author><category term="mathematica" /><category term="linear algebra" /><summary type="html"><![CDATA[Transpose and Flatten]]></summary></entry><entry><title type="html">Mathematica tips for numerical linear algebra (3)</title><link href="https://aashmore.github.io/2022/06/23/mathematica-3.html" rel="alternate" type="text/html" title="Mathematica tips for numerical linear algebra (3)" /><published>2022-06-23T00:00:00+00:00</published><updated>2022-06-23T00:00:00+00:00</updated><id>https://aashmore.github.io/2022/06/23/mathematica-3</id><content type="html" xml:base="https://aashmore.github.io/2022/06/23/mathematica-3.html"><![CDATA[<h2 id="mathematica-is-smart">Mathematica is smart</h2>

<!-- excerpt start -->
<p>The take-away from this is that many clever people have worked for a very long time on optimising the Mathematica’s built-in functions, such as <code class="language-plaintext highlighter-rouge">Dot</code>. In particular, when <code class="language-plaintext highlighter-rouge">Dot</code> is called, it turns the calculation over to a set of C++ libraries for numerical linear algebra known as the Intel MKL. 
<!-- excerpt end -->
Of course, we could just do all of this in C++ and call MKL directly. Usually, however, the time saved in the calculation itself is not worth the extra headaches of coding in C++ and having to recompile just to try out a new idea. Mathematica allows us to play with ideas and have performance close to (within a factor of three or so) doing everything in C++. And as we’ll see in a future post, Mathematica can take advantage of multiple CPU cores without us really having to think about it.</p>

<p>We can see the same behaviour play out with higher-rank tensors. Imagine we want to contract a matrix with another matrix: $m_{ab}n_{bc} = (mn)_ac$. We could implement this as</p>

<div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">RandomComplex</span><span class="p">[{}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="m">500</span><span class="o">,</span><span class="w"> </span><span class="m">1000</span><span class="p">}]</span><span class="o">;</span><span class="w">
</span><span class="nv">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">RandomComplex</span><span class="p">[{}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="m">1000</span><span class="o">,</span><span class="w"> </span><span class="m">750</span><span class="p">}]</span><span class="o">;</span><span class="w">

</span><span class="nv">m</span><span class="o">.</span><span class="nv">n</span><span class="o">;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nb">AbsoluteTiming</span><span class="w">
</span><span class="c">(* 0.0735985 s *)</span><span class="w">
</span></code></pre></div></div>

<p>Not bad! Just let Mathematica do the dirty work! Note that Mathematica thinks of these matrices as arrays (or more accurately <code class="language-plaintext highlighter-rouge">Lists</code>) of dimensions <code class="language-plaintext highlighter-rouge">{500,1000}</code> and <code class="language-plaintext highlighter-rouge">{1000,750}</code> respectively:</p>

<div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">m</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nb">Dimensions</span><span class="w">
</span><span class="c">(* {500,1000} *)</span><span class="w">
</span><span class="nv">n</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nb">Dimensions</span><span class="w">
</span><span class="c">(* {1000,750} *)</span><span class="w">
</span><span class="nv">m</span><span class="o">.</span><span class="nv">n</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nb">Dimensions</span><span class="w">
</span><span class="c">(* {500,750} *)</span><span class="w">
</span></code></pre></div></div>

<p>This also gives us an idea of what Mathematica is doing with <code class="language-plaintext highlighter-rouge">Dot</code> – the length of the last dimension of $m$  must match the length of the first dimension of $n$ (since it is contracting these indices). The resulting array is labelled by the remaining indices of $m$ and $n$ in the order they appear in according to $m_{ab} n_{bc} = (m n)_{ac}$.</p>]]></content><author><name>anthony-ashmore</name></author><category term="mathematica" /><category term="linear algebra" /><summary type="html"><![CDATA[Mathematica is smart]]></summary></entry><entry><title type="html">Mathematica tips for numerical linear algebra (2)</title><link href="https://aashmore.github.io/2022/04/03/mathematica-2.html" rel="alternate" type="text/html" title="Mathematica tips for numerical linear algebra (2)" /><published>2022-04-03T00:00:00+00:00</published><updated>2022-04-03T00:00:00+00:00</updated><id>https://aashmore.github.io/2022/04/03/mathematica-2</id><content type="html" xml:base="https://aashmore.github.io/2022/04/03/mathematica-2.html"><![CDATA[<h2 id="dot-products">Dot products</h2>

<!-- excerpt start -->
<p>The bulk of the numerical calculations that I need are basically linear algebra – matrix-matrix, vector-matrix and more exotic multiplications. All of the entries in these tensors are “machine precision”, which roughly translates to a C++ double. Mathematica can store these numbers as “packed arrays” – working with machine precision numbers rather than “exact” quantities greatly speeds up calculations (if they are written in the right way).
<!-- excerpt end --></p>

<p>Let’s start with a simple example where we want to take the dot product of two vectors $u$ and $v$. In index notation this is simply $u \cdot v =u_a v_a$, so we can think of the dot product as simply multiplying and then summing the individual entries of the vectors. Mathematica has many ways to carry out such a simple calculation, but picking the right way now will make sure more complicated calculations don’t take all weekend!</p>

<div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">10</span><span class="o">;</span><span class="w"> </span><span class="c">(* size of vectors *)</span><span class="w">
</span><span class="nv">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">RandomComplex</span><span class="p">[{}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">l</span><span class="p">}]</span><span class="o">;</span><span class="w">
</span><span class="nv">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">RandomComplex</span><span class="p">[{}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">l</span><span class="p">}]</span><span class="o">;</span><span class="w">

</span><span class="nb">Sum</span><span class="p">[</span><span class="nv">u</span><span class="p">[[</span><span class="nv">i</span><span class="p">]]</span><span class="w"> </span><span class="nv">v</span><span class="p">[[</span><span class="nv">i</span><span class="p">]]</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">i</span><span class="o">,</span><span class="w"> </span><span class="m">1</span><span class="o">,</span><span class="w"> </span><span class="nv">l</span><span class="p">}]</span><span class="w">
</span><span class="nb">Total</span><span class="p">[</span><span class="nv">u</span><span class="o">*</span><span class="nv">v</span><span class="p">]</span><span class="w">
</span><span class="nv">u</span><span class="o">.</span><span class="nv">v</span><span class="w">
</span></code></pre></div></div>

<p>Here we’ve defined our vectors to be of length $l$. <code class="language-plaintext highlighter-rouge">RandomComplex</code> then gives a list whose entries are machine-precision complex numbers. We have given three ways to calculate the dot product.</p>

<ul>
  <li>
    <p>The first is closest to what one might do in C++ where we simply loop over the entries and sum them together. Though this might be the most obvious thing to do, this is nearly always the slowest (as we’ll see below).</p>
  </li>
  <li>
    <p>The next way uses the Mathematica operator <code class="language-plaintext highlighter-rouge">*</code> which in this instance takes in two vectors and outputs a third vector whose entries are given by $(u*v)_a = u_a v_a$  with no sum over $a$. We can then sum the entries of this new vector using <code class="language-plaintext highlighter-rouge">Total</code> to get the dot product.</p>
  </li>
  <li>
    <p>Our third way is simply using the built-in Mathematica function <code class="language-plaintext highlighter-rouge">Dot[u,v]</code>, which can also be called as <code class="language-plaintext highlighter-rouge">u.v</code>.</p>
  </li>
</ul>

<p>For relatively small vectors, any of these will do. However, when one is dealing with numerical calculations with millions of points, there are big differences between them. For example, let’s increase the length of the vectors to ten million and check how long each method takes.</p>

<div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">10</span><span class="o">^</span><span class="m">7</span><span class="o">;</span><span class="w"> </span><span class="c">(* size of vectors *)</span><span class="w">
</span><span class="nv">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">RandomComplex</span><span class="p">[{}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">l</span><span class="p">}]</span><span class="o">;</span><span class="w">
</span><span class="nv">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">RandomComplex</span><span class="p">[{}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">l</span><span class="p">}]</span><span class="o">;</span><span class="w">

</span><span class="nb">Sum</span><span class="p">[</span><span class="nv">u</span><span class="p">[[</span><span class="nv">i</span><span class="p">]]</span><span class="w"> </span><span class="nv">v</span><span class="p">[[</span><span class="nv">i</span><span class="p">]]</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">i</span><span class="o">,</span><span class="w"> </span><span class="m">1</span><span class="o">,</span><span class="w"> </span><span class="nv">l</span><span class="p">}]</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nb">AbsoluteTiming</span><span class="w">
</span><span class="c">(* 29.6766 s *)</span><span class="w">
</span><span class="nb">Total</span><span class="p">[</span><span class="nv">u</span><span class="o">*</span><span class="nv">v</span><span class="p">]</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nb">AbsoluteTiming</span><span class="w">
</span><span class="c">(* 0.155223 s *)</span><span class="w">
</span><span class="nv">u</span><span class="o">.</span><span class="nv">v</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nb">AbsoluteTiming</span><span class="w">
</span><span class="c">(* 0.036661 s *)</span><span class="w">
</span></code></pre></div></div>

<p>Uh oh! Explicitly summing over the elements of the vectors as one might do in C++ is crazy slow, taking over 800 times longer than using <code class="language-plaintext highlighter-rouge">Dot</code>. Notice that using <code class="language-plaintext highlighter-rouge">Total</code> is slower than <code class="language-plaintext highlighter-rouge">Dot</code> – you might have expected this since <code class="language-plaintext highlighter-rouge">u*v</code> constructs a new vector which <code class="language-plaintext highlighter-rouge">Total</code> then sums, whereas <code class="language-plaintext highlighter-rouge">Dot</code> just computes the sum directly. So what’s up?</p>]]></content><author><name>anthony-ashmore</name></author><category term="mathematica" /><category term="linear algebra" /><summary type="html"><![CDATA[Dot products]]></summary></entry><entry><title type="html">Mathematica tips for numerical linear algebra (1)</title><link href="https://aashmore.github.io/2022/01/13/mathematica-1.html" rel="alternate" type="text/html" title="Mathematica tips for numerical linear algebra (1)" /><published>2022-01-13T00:00:00+00:00</published><updated>2022-01-13T00:00:00+00:00</updated><id>https://aashmore.github.io/2022/01/13/mathematica-1</id><content type="html" xml:base="https://aashmore.github.io/2022/01/13/mathematica-1.html"><![CDATA[<!-- excerpt start -->
<p>Calabi-Yau manifolds are special as they are Kähler manifolds which admit Ricci-flat metrics. As of the end of 2020, there are still no complete analytic expressions for such metrics on compact manifolds, other than in the somewhat trivial cases of tori. Instead, the best we can do are approximate numerical metrics. I became interested in this a couple of years ago when trying to learn some of the machine-learning techniques that are all the rage at the moment. But before I could I apply all this fancy new technology, I first needed some data to work with. And so I found myself needing to understand how to generate these numerical metrics.
<!-- excerpt end --></p>

<p>Previous work on these numerical metrics had used C++. Unfortunately, my experience with C++ is limited to a “Teach Yourself C++ in 24 Hours” book and some bad memories of pointers in undergraduate computing labs. Since I didn’t want to reinvent the wheel, I decided I’d try to implement the numerical metrics using Mathematica instead. I figured this would make the code much easier to handle and it would be closer to the kind of language (tensors and so on) that I would use if I were doing a calculation with pen and paper.</p>

<p>And so here we are almost two years later. I did manage to do what I wanted using only Mathematica. It took a few late nights of scouring the Wolfram documentation and copious amounts of help from StackExchange, but I think it really was easier than keeping track of hundreds of .cc and .h files (and trying to decipher completely cryptic compiler errors). Along the way, I learned a few neat tricks and tips for working with numerical calculations in Mathematica that I figure might be of use to someone else, and so I’m going to lay them out in the next few posts for the interested reader.</p>]]></content><author><name>anthony-ashmore</name></author><category term="mathematica" /><category term="linear algebra" /><summary type="html"><![CDATA[Calabi-Yau manifolds are special as they are Kähler manifolds which admit Ricci-flat metrics. As of the end of 2020, there are still no complete analytic expressions for such metrics on compact manifolds, other than in the somewhat trivial cases of tori. Instead, the best we can do are approximate numerical metrics. I became interested in this a couple of years ago when trying to learn some of the machine-learning techniques that are all the rage at the moment. But before I could I apply all this fancy new technology, I first needed some data to work with. And so I found myself needing to understand how to generate these numerical metrics.]]></summary></entry></feed>