<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://aashmore.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://aashmore.github.io/" rel="alternate" type="text/html" /><updated>2024-10-07T14:24:06+00:00</updated><id>https://aashmore.github.io/feed.xml</id><title type="html">Ashmore Lab</title><subtitle>A computational physics and machine learning research group at Skidmore College.</subtitle><entry><title type="html">Mathematica tips for numerical linear algebra (3)</title><link href="https://aashmore.github.io/2023/02/23/example-post-3.html" rel="alternate" type="text/html" title="Mathematica tips for numerical linear algebra (3)" /><published>2023-02-23T00:00:00+00:00</published><updated>2023-02-23T00:00:00+00:00</updated><id>https://aashmore.github.io/2023/02/23/example-post-3</id><content type="html" xml:base="https://aashmore.github.io/2023/02/23/example-post-3.html"><![CDATA[<h2 id="dot-products">Dot products</h2>

<!-- excerpt start -->
<p>The bulk of the numerical calculations that I need are basically linear algebra – matrix-matrix, vector-matrix and more exotic multiplications. All of the entries in these tensors are “machine precision”, which roughly translates to a C++ double. Mathematica can store these numbers as “packed arrays” – working with machine precision numbers rather than “exact” quantities greatly speeds up calculations (if they are written in the right way).
<!-- excerpt end --></p>

<p>Let’s start with a simple example where we want to take the dot product of two vectors $u$ and $v$. In index notation this is simply $u \cdot v =u_a v_a$, so we can think of the dot product as simply multiplying and then summing the individual entries of the vectors. Mathematica has many ways to carry out such a simple calculation, but picking the right way now will make sure more complicated calculations don’t take all weekend!</p>

<div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">10</span><span class="o">;</span><span class="w"> </span><span class="c">(* size of vectors *)</span><span class="w">
</span><span class="nv">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">RandomComplex</span><span class="p">[{}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">l</span><span class="p">}]</span><span class="o">;</span><span class="w">
</span><span class="nv">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">RandomComplex</span><span class="p">[{}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">l</span><span class="p">}]</span><span class="o">;</span><span class="w">

</span><span class="nb">Sum</span><span class="p">[</span><span class="nv">u</span><span class="p">[[</span><span class="nv">i</span><span class="p">]]</span><span class="w"> </span><span class="nv">v</span><span class="p">[[</span><span class="nv">i</span><span class="p">]]</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">i</span><span class="o">,</span><span class="w"> </span><span class="m">1</span><span class="o">,</span><span class="w"> </span><span class="nv">l</span><span class="p">}]</span><span class="w">
</span><span class="nb">Total</span><span class="p">[</span><span class="nv">u</span><span class="o">*</span><span class="nv">v</span><span class="p">]</span><span class="w">
</span><span class="nv">u</span><span class="o">.</span><span class="nv">v</span><span class="w">
</span></code></pre></div></div>

<p>Here we’ve defined our vectors to be of length $l$. <code class="language-plaintext highlighter-rouge">RandomComplex</code> then gives a list whose entries are machine-precision complex numbers. We have given three ways to calculate the dot product.</p>

<ul>
  <li>
    <p>The first is closest to what one might do in C++ where we simply loop over the entries and sum them together. Though this might be the most obvious thing to do, this is nearly always the slowest (as we’ll see below).</p>
  </li>
  <li>
    <p>The next way uses the Mathematica operator <code class="language-plaintext highlighter-rouge">*</code> which in this instance takes in two vectors and outputs a third vector whose entries are given by $(u*v)_a = u_a v_a$  with no sum over $a$. We can then sum the entries of this new vector using <code class="language-plaintext highlighter-rouge">Total</code> to get the dot product.</p>
  </li>
  <li>
    <p>Our third way is simply using the built-in Mathematica function <code class="language-plaintext highlighter-rouge">Dot[u,v]</code>, which can also be called as <code class="language-plaintext highlighter-rouge">u.v</code>.</p>
  </li>
</ul>

<p>For relatively small vectors, any of these will do. However, when one is dealing with numerical calculations with millions of points, there are big differences between them. For example, let’s increase the length of the vectors to ten million and check how long each method takes.</p>

<div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">10</span><span class="o">^</span><span class="m">7</span><span class="o">;</span><span class="w"> </span><span class="c">(* size of vectors *)</span><span class="w">
</span><span class="nv">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">RandomComplex</span><span class="p">[{}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">l</span><span class="p">}]</span><span class="o">;</span><span class="w">
</span><span class="nv">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">RandomComplex</span><span class="p">[{}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">l</span><span class="p">}]</span><span class="o">;</span><span class="w">

</span><span class="nb">Sum</span><span class="p">[</span><span class="nv">u</span><span class="p">[[</span><span class="nv">i</span><span class="p">]]</span><span class="w"> </span><span class="nv">v</span><span class="p">[[</span><span class="nv">i</span><span class="p">]]</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">i</span><span class="o">,</span><span class="w"> </span><span class="m">1</span><span class="o">,</span><span class="w"> </span><span class="nv">l</span><span class="p">}]</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nb">AbsoluteTiming</span><span class="w">
</span><span class="c">(* 29.6766 s *)</span><span class="w">
</span><span class="nb">Total</span><span class="p">[</span><span class="nv">u</span><span class="o">*</span><span class="nv">v</span><span class="p">]</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nb">AbsoluteTiming</span><span class="w">
</span><span class="c">(* 0.155223 s *)</span><span class="w">
</span><span class="nv">u</span><span class="o">.</span><span class="nv">v</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nb">AbsoluteTiming</span><span class="w">
</span><span class="c">(* 0.036661 s *)</span><span class="w">
</span></code></pre></div></div>

<p>Uh oh! Explicitly summing over the elements of the vectors as one might do in C++ is crazy slow, taking over 800 times longer than using <code class="language-plaintext highlighter-rouge">Dot</code>. Notice that using <code class="language-plaintext highlighter-rouge">Total</code> is slower than <code class="language-plaintext highlighter-rouge">Dot</code> – you might have expected this since <code class="language-plaintext highlighter-rouge">u*v</code> constructs a new vector which <code class="language-plaintext highlighter-rouge">Total</code> then sums, whereas <code class="language-plaintext highlighter-rouge">Dot</code> just computes the sum directly. So what’s up?</p>]]></content><author><name>anthony-ashmore</name></author><category term="mathematica" /><category term="linear algebra" /><summary type="html"><![CDATA[Dot products]]></summary></entry><entry><title type="html">Mathematica tips for numerical linear algebra (1)</title><link href="https://aashmore.github.io/2022/01/13/mathematica-1.html" rel="alternate" type="text/html" title="Mathematica tips for numerical linear algebra (1)" /><published>2022-01-13T00:00:00+00:00</published><updated>2022-01-13T00:00:00+00:00</updated><id>https://aashmore.github.io/2022/01/13/mathematica-1</id><content type="html" xml:base="https://aashmore.github.io/2022/01/13/mathematica-1.html"><![CDATA[<!-- excerpt start -->
<p>Calabi-Yau manifolds are special as they are Kähler manifolds which admit Ricci-flat metrics. As of the end of 2020, there are still no complete analytic expressions for such metrics on compact manifolds, other than in the somewhat trivial cases of tori. Instead, the best we can do are approximate numerical metrics. I became interested in this a couple of years ago when trying to learn some of the machine-learning techniques that are all the rage at the moment. But before I could I apply all this fancy new technology, I first needed some data to work with. And so I found myself needing to understand how to generate these numerical metrics.
<!-- excerpt end --></p>

<p>Previous work on these numerical metrics had used C++. Unfortunately, my experience with C++ is limited to a “Teach Yourself C++ in 24 Hours” book and some bad memories of pointers in undergraduate computing labs. Since I didn’t want to reinvent the wheel, I decided I’d try to implement the numerical metrics using Mathematica instead. I figured this would make the code much easier to handle and it would be closer to the kind of language (tensors and so on) that I would use if I were doing a calculation with pen and paper.</p>

<p>And so here we are almost two years later. I did manage to do what I wanted using only Mathematica. It took a few late nights of scouring the Wolfram documentation and copious amounts of help from StackExchange, but I think it really was easier than keeping track of hundreds of .cc and .h files (and trying to decipher completely cryptic compiler errors). Along the way, I learned a few neat tricks and tips for working with numerical calculations in Mathematica that I figure might be of use to someone else, and so I’m going to lay them out in the next few posts for the interested reader.</p>]]></content><author><name>anthony-ashmore</name></author><category term="mathematica" /><category term="linear algebra" /><summary type="html"><![CDATA[Calabi-Yau manifolds are special as they are Kähler manifolds which admit Ricci-flat metrics. As of the end of 2020, there are still no complete analytic expressions for such metrics on compact manifolds, other than in the somewhat trivial cases of tori. Instead, the best we can do are approximate numerical metrics. I became interested in this a couple of years ago when trying to learn some of the machine-learning techniques that are all the rage at the moment. But before I could I apply all this fancy new technology, I first needed some data to work with. And so I found myself needing to understand how to generate these numerical metrics.]]></summary></entry><entry><title type="html">Mathematica tips for numerical linear algebra (2)</title><link href="https://aashmore.github.io/2022/01/13/mathematica-2.html" rel="alternate" type="text/html" title="Mathematica tips for numerical linear algebra (2)" /><published>2022-01-13T00:00:00+00:00</published><updated>2022-01-13T00:00:00+00:00</updated><id>https://aashmore.github.io/2022/01/13/mathematica-2</id><content type="html" xml:base="https://aashmore.github.io/2022/01/13/mathematica-2.html"><![CDATA[<h2 id="dot-products">Dot products</h2>

<!-- excerpt start -->
<p>The bulk of the numerical calculations that I need are basically linear algebra – matrix-matrix, vector-matrix and more exotic multiplications. All of the entries in these tensors are “machine precision”, which roughly translates to a C++ double. Mathematica can store these numbers as “packed arrays” – working with machine precision numbers rather than “exact” quantities greatly speeds up calculations (if they are written in the right way).
<!-- excerpt end --></p>

<p>Let’s start with a simple example where we want to take the dot product of two vectors $u$ and $v$. In index notation this is simply $u \cdot v =u_a v_a$, so we can think of the dot product as simply multiplying and then summing the individual entries of the vectors. Mathematica has many ways to carry out such a simple calculation, but picking the right way now will make sure more complicated calculations don’t take all weekend!</p>

<div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">10</span><span class="o">;</span><span class="w"> </span><span class="c">(* size of vectors *)</span><span class="w">
</span><span class="nv">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">RandomComplex</span><span class="p">[{}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">l</span><span class="p">}]</span><span class="o">;</span><span class="w">
</span><span class="nv">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">RandomComplex</span><span class="p">[{}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">l</span><span class="p">}]</span><span class="o">;</span><span class="w">

</span><span class="nb">Sum</span><span class="p">[</span><span class="nv">u</span><span class="p">[[</span><span class="nv">i</span><span class="p">]]</span><span class="w"> </span><span class="nv">v</span><span class="p">[[</span><span class="nv">i</span><span class="p">]]</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">i</span><span class="o">,</span><span class="w"> </span><span class="m">1</span><span class="o">,</span><span class="w"> </span><span class="nv">l</span><span class="p">}]</span><span class="w">
</span><span class="nb">Total</span><span class="p">[</span><span class="nv">u</span><span class="o">*</span><span class="nv">v</span><span class="p">]</span><span class="w">
</span><span class="nv">u</span><span class="o">.</span><span class="nv">v</span><span class="w">
</span></code></pre></div></div>

<p>Here we’ve defined our vectors to be of length $l$. <code class="language-plaintext highlighter-rouge">RandomComplex</code> then gives a list whose entries are machine-precision complex numbers. We have given three ways to calculate the dot product.</p>

<ul>
  <li>
    <p>The first is closest to what one might do in C++ where we simply loop over the entries and sum them together. Though this might be the most obvious thing to do, this is nearly always the slowest (as we’ll see below).</p>
  </li>
  <li>
    <p>The next way uses the Mathematica operator <code class="language-plaintext highlighter-rouge">*</code> which in this instance takes in two vectors and outputs a third vector whose entries are given by $(u*v)_a = u_a v_a$  with no sum over $a$. We can then sum the entries of this new vector using <code class="language-plaintext highlighter-rouge">Total</code> to get the dot product.</p>
  </li>
  <li>
    <p>Our third way is simply using the built-in Mathematica function <code class="language-plaintext highlighter-rouge">Dot[u,v]</code>, which can also be called as <code class="language-plaintext highlighter-rouge">u.v</code>.</p>
  </li>
</ul>

<p>For relatively small vectors, any of these will do. However, when one is dealing with numerical calculations with millions of points, there are big differences between them. For example, let’s increase the length of the vectors to ten million and check how long each method takes.</p>

<div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">10</span><span class="o">^</span><span class="m">7</span><span class="o">;</span><span class="w"> </span><span class="c">(* size of vectors *)</span><span class="w">
</span><span class="nv">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">RandomComplex</span><span class="p">[{}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">l</span><span class="p">}]</span><span class="o">;</span><span class="w">
</span><span class="nv">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">RandomComplex</span><span class="p">[{}</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">l</span><span class="p">}]</span><span class="o">;</span><span class="w">

</span><span class="nb">Sum</span><span class="p">[</span><span class="nv">u</span><span class="p">[[</span><span class="nv">i</span><span class="p">]]</span><span class="w"> </span><span class="nv">v</span><span class="p">[[</span><span class="nv">i</span><span class="p">]]</span><span class="o">,</span><span class="w"> </span><span class="p">{</span><span class="nv">i</span><span class="o">,</span><span class="w"> </span><span class="m">1</span><span class="o">,</span><span class="w"> </span><span class="nv">l</span><span class="p">}]</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nb">AbsoluteTiming</span><span class="w">
</span><span class="c">(* 29.6766 s *)</span><span class="w">
</span><span class="nb">Total</span><span class="p">[</span><span class="nv">u</span><span class="o">*</span><span class="nv">v</span><span class="p">]</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nb">AbsoluteTiming</span><span class="w">
</span><span class="c">(* 0.155223 s *)</span><span class="w">
</span><span class="nv">u</span><span class="o">.</span><span class="nv">v</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nb">AbsoluteTiming</span><span class="w">
</span><span class="c">(* 0.036661 s *)</span><span class="w">
</span></code></pre></div></div>

<p>Uh oh! Explicitly summing over the elements of the vectors as one might do in C++ is crazy slow, taking over 800 times longer than using <code class="language-plaintext highlighter-rouge">Dot</code>. Notice that using <code class="language-plaintext highlighter-rouge">Total</code> is slower than <code class="language-plaintext highlighter-rouge">Dot</code> – you might have expected this since <code class="language-plaintext highlighter-rouge">u*v</code> constructs a new vector which <code class="language-plaintext highlighter-rouge">Total</code> then sums, whereas <code class="language-plaintext highlighter-rouge">Dot</code> just computes the sum directly. So what’s up?</p>]]></content><author><name>anthony-ashmore</name></author><category term="mathematica" /><category term="linear algebra" /><summary type="html"><![CDATA[Dot products]]></summary></entry></feed>